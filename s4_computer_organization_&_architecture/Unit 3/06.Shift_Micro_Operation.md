# Shift Micro-Operations
---

## 1. What are Shift Micro-Operations?

Shift micro-operations **move (shift) bits** in a register to the **left or right** by one or more positions in a single clock cycle.

**Key Terminology:**
- **MSB (Most Significant Bit)** = Leftmost bit (highest value position)
- **LSB (Least Significant Bit)** = Rightmost bit (lowest value position)
- **Vacant position** = The empty spot created after bits are moved

```
8-bit Register:

Position:   7   6   5   4   3   2   1   0
            ↑                           ↑
           MSB                         LSB
```

> **Why Shift?**
> - Shift Left by 1 position = **Multiply by 2**
> - Shift Right by 1 position = **Divide by 2**
> - Also used for serial data transmission, cryptography, and bit manipulation.

---

## 2. Types of Shift Micro-Operations

There are **4 types** of shifts:
1. Logical Shift
2. Arithmetic Shift
3. Circular Shift (Rotate)
4. Rotate Through Carry

---

## 3. Logical Shift

### What is Logical Shift?

In logical shift, bits move left or right and the **vacant position is always filled with 0**. Bits that fall off the edge are **lost permanently**.

> **Rule to remember:** Logical Shift = **"Zero Fill"** — vacant spot always gets 0.

---

### 3.1 Logical Shift Left (shl)

**What happens:**
- All bits move **one position to the LEFT**
- **MSB** (leftmost bit) falls off and is **lost**
- **LSB** (rightmost position) is filled with **0**

**RTL Notation:** `R ← shl R`

**Diagram:**
```
Before:  [ b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 ]

          ← ← ← ← ← ← ← ← ← ← ← (shift left)
          b7 falls off (lost)                  0 enters

After:   [ b6 | b5 | b4 | b3 | b2 | b1 | b0 |  0 ]
```

**Worked Example:**
```
R = 1 1 0 1 1 0 1 0

Step: Shift all bits left by 1
      MSB (1) falls off → lost
      0 enters at LSB

R after shl = 1 0 1 1 0 1 0 0

Verify:
  Original:  1 1 0 1 1 0 1 0  = 218 (decimal)
  After shl: 1 0 1 1 0 1 0 0  = 180 (decimal)

Note: 218 × 2 = 436 — but result is 180, NOT 436!
Because 218 is too large for 8-bit (max = 255) → MSB was carrying value that got lost = OVERFLOW occurred.
```

**Another Example (no overflow):**
```
R = 0 0 0 0 1 1 0 1  = 13 (decimal)

After shl = 0 0 0 1 1 0 1 0  = 26 (decimal)

13 × 2 = 26 ✓  (no overflow because MSB was 0)
```

> **Logical Shift Left = Multiply by 2 (only if no overflow — MSB must be 0 before shift)**

---

### 3.2 Logical Shift Right (shr)

**What happens:**
- All bits move **one position to the RIGHT**
- **LSB** (rightmost bit) falls off and is **lost**
- **MSB** (leftmost position) is filled with **0**

**RTL Notation:** `R ← shr R`

**Diagram:**
```
Before:  [ b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 ]

          → → → → → → → → → → → (shift right)
          0 enters                      b0 falls off (lost)

After:   [  0 | b7 | b6 | b5 | b4 | b3 | b2 | b1 ]
```

**Worked Example:**
```
R = 1 1 0 1 1 0 1 0  = 218 (decimal)

Step: Shift all bits right by 1
      LSB (0) falls off → lost
      0 enters at MSB

R after shr = 0 1 1 0 1 1 0 1  = 109 (decimal)

218 ÷ 2 = 109 ✓
```

**Another Example:**
```
R = 0 0 1 1 0 1 0 1  = 53 (decimal)

After shr = 0 0 0 1 1 0 1 0  = 26 (decimal)

53 ÷ 2 = 26.5 → integer division = 26 ✓ (LSB=1 was the 0.5, it was lost)
```

> **Logical Shift Right = Divide by 2 (integer division — remainder is lost with LSB)**

> **Important:** Logical shift right is for **unsigned numbers only**. For signed (negative) numbers, it gives wrong results because MSB (sign bit) gets replaced with 0. For signed numbers, use **Arithmetic Shift Right**.

---

## 4. Arithmetic Shift

### What is Arithmetic Shift?

Arithmetic shift is designed specifically for **signed numbers (2's complement representation)**.

> **Signed number reminder:**
> - MSB = **0** → Positive number
> - MSB = **1** → Negative number
>
> The MSB is called the **Sign Bit**. Arithmetic shift **preserves the sign bit** during right shift.

---

### 4.1 Arithmetic Shift Left (asl)

**What happens:**
- **Same as Logical Shift Left** — bits move left, 0 enters at LSB, MSB is lost
- **Difference:** If MSB changes (overflow), the sign of the number changes — this is an **overflow error**

**RTL Notation:** `R ← shl R` (same notation, context determines arithmetic/logical)

**Diagram:**
```
Before:  [ Sign | b6 | b5 | b4 | b3 | b2 | b1 | b0 ]

          ← ← ← ← ← ← ← ← ← ← (shift left)
          Sign bit falls off                    0 enters

After:   [  b6  | b5 | b4 | b3 | b2 | b1 | b0 |  0 ]
```

**Worked Example (No Overflow — Positive):**
```
R = 0 0 0 1 0 1 0 0  = +20 (decimal, MSB=0 → positive)

After asl = 0 0 1 0 1 0 0 0  = +40 (decimal)

+20 × 2 = +40 ✓ (MSB still 0 → still positive → no overflow)
```

**Worked Example (Overflow — Sign Changed!):**
```
R = 0 1 0 0 0 0 0 0  = +64 (decimal)

After asl = 1 0 0 0 0 0 0 0  = -128 (decimal, MSB=1 → negative!)

+64 × 2 should be +128, but result is -128 → OVERFLOW! 
(MSB changed from 0 to 1 — sign flipped — result is wrong)
```

> **Overflow in Arithmetic Left Shift:** Occurs when the MSB changes after the shift (i.e., sign of the number changes). This means the result is too large to fit in the register.

---

### 4.2 Arithmetic Shift Right (asr)

**What happens:**
- All bits move **one position to the RIGHT**
- **LSB** falls off and is **lost**
- **MSB (Sign bit) is COPIED** (replicated) into the vacant MSB position — sign is preserved!

**RTL Notation:** `R ← shr R`

**Diagram:**
```
Before:  [ Sign | b6 | b5 | b4 | b3 | b2 | b1 | b0 ]

          → → → → → → → → → → → (shift right)
     Sign copied here                         b0 falls off (lost)

After:   [ Sign | Sign | b6 | b5 | b4 | b3 | b2 | b1 ]
             ↑
         (same as before — copied, not moved)
```

**Worked Example (Positive Number):**
```
R = 0 1 1 0 1 0 0 0  = +104 (decimal, MSB=0 → positive)

Sign bit = 0
After asr: Copy 0 into MSB, shift rest right, LSB(0) lost

R after asr = 0 0 1 1 0 1 0 0  = +52 (decimal)

+104 ÷ 2 = +52 ✓ (Sign preserved — still positive)
```

**Worked Example (Negative Number):**
```
R = 1 1 0 0 1 0 0 0  = -56 (decimal, MSB=1 → negative)

Sign bit = 1
After asr: Copy 1 into MSB, shift rest right, LSB(0) lost

R after asr = 1 1 1 0 0 1 0 0  = -28 (decimal)

-56 ÷ 2 = -28 ✓ (Sign preserved — still negative!)
```

> **This is the KEY difference — Arithmetic Right Shift copies the sign bit, Logical Right Shift always fills with 0.**

---

### Logical vs Arithmetic Right Shift — Critical Difference

```
Number: R = 1 0 0 0 1 1 0 0  (MSB=1 → negative number = -116 in decimal)

Logical Shift Right:
  R = 0 1 0 0 0 1 1 0  = +70  → WRONG for signed numbers (sign changed!)

Arithmetic Shift Right:
  R = 1 1 0 0 0 1 1 0  = -58  → CORRECT (−116 ÷ 2 = −58 ✓)
```

> **Summary:**
> - **Logical Right Shift** → always fills MSB with **0** → for **unsigned numbers**
> - **Arithmetic Right Shift** → fills MSB with **sign bit copy** → for **signed numbers**

---

## 5. Circular Shift (Rotate)

### What is Circular Shift?

In circular shift (also called **rotate**), bits that fall off one end **wrap around and re-enter from the other end**. **No bits are ever lost.**

> **Key property:** Circular shift is like a ring — bits go round and round. After n shifts (where n = register size), the register returns to its original value.

---

### 5.1 Circular Shift Left (cil)

**What happens:**
- All bits move **one position to the LEFT**
- **MSB** (that would fall off) wraps around and enters at the **LSB** position

**RTL Notation:** `R ← cil R`

**Diagram:**
```
      ┌────────────────────────────────────────┐
      │                                        │
      ↓                                        │
Before: [ b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 ]
                                               │
         ← ← ← ← ← ← ← ← ← ← ←              │
         b7 wraps around to LSB ───────────────┘

After:  [ b6 | b5 | b4 | b3 | b2 | b1 | b0 | b7 ]
```

**Worked Example:**
```
R = 1 0 1 1 0 1 1 0

Step: MSB (1) wraps to LSB, rest shift left

R after cil = 0 1 1 0 1 1 0 1
                              ↑
                        MSB (1) came here
```

**Verify — nothing lost:**
```
Original bits: 1,0,1,1,0,1,1,0  (8 bits)
After cil:     0,1,1,0,1,1,0,1  (same 8 bits — just rotated!)
```

---

### 5.2 Circular Shift Right (cir)

**What happens:**
- All bits move **one position to the RIGHT**
- **LSB** (that would fall off) wraps around and enters at the **MSB** position

**RTL Notation:** `R ← cir R`

**Diagram:**
```
┌────────────────────────────────────────┐
│                                        │
│                                        ↓
Before: [ b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 ]
│
│         → → → → → → → → → → →
└── b0 wraps around to MSB

After:  [ b0 | b7 | b6 | b5 | b4 | b3 | b2 | b1 ]
```

**Worked Example:**
```
R = 1 0 1 1 0 1 1 0

Step: LSB (0) wraps to MSB, rest shift right

R after cir = 0 1 0 1 1 0 1 1
              ↑
        LSB (0) came here
```

**Verify — nothing lost:**
```
Original bits: 1,0,1,1,0,1,1,0  (8 bits)
After cir:     0,1,0,1,1,0,1,1  (same 8 bits — just rotated!)
```

**Property — Restore after 8 shifts:**
```
If we do cil 8 times on an 8-bit register:
R → cil → cil → cil → cil → cil → cil → cil → cil → original R
```

---

## 6. Rotate Through Carry

### What is Rotate Through Carry?

A variant of circular shift where the **Carry flag (C)** acts as an **extra 1-bit extension** of the register during rotation.

> **Carry Flag (C):** A 1-bit register in the CPU that stores the carry/overflow from arithmetic operations. It is part of the **Flag/Status Register**.
>
> In Rotate Through Carry, the register becomes effectively **9-bit** (8-bit register + 1-bit carry).

---

### 6.1 Rotate Left Through Carry (rcl)

**What happens:**
- All bits shift **left**
- **MSB** goes into the **Carry flag (C)**
- **Old value of C** enters at the **LSB**

**Diagram:**
```
        ┌──────────────────────────────────────────────┐
        │                                              │
        ↓                                              │
[ C ] ← [ b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 ] ←─┘
  ↑
MSB goes into C, old C comes into LSB

Before: C=1,  R = 0 1 1 0 1 0 1 0
After:  C=0,  R = 1 1 0 1 0 1 0 1
              ↑                 ↑
         (old MSB=0        (old C=1 entered)
         went to C)
```

**Worked Example:**
```
Before: C = 1,  R = 0 1 1 0 1 0 1 0

Step 1: MSB (0) → goes into C
Step 2: All bits shift left
Step 3: Old C (1) → enters at LSB

After:  C = 0,  R = 1 1 0 1 0 1 0 1
```

---

### 6.2 Rotate Right Through Carry (rcr)

**What happens:**
- All bits shift **right**
- **LSB** goes into the **Carry flag (C)**
- **Old value of C** enters at the **MSB**

**Diagram:**
```
┌──────────────────────────────────────────────┐
│                                              │
│                                              ↓
└─→ [ b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 ] → [ C ]

Old C enters at MSB, LSB goes into C

Before: C=0,  R = 1 0 1 1 0 1 0 1
After:  C=1,  R = 0 1 0 1 1 0 1 0
        ↑     ↑                 ↑
    LSB(1)  (old C=0        (old LSB=1
    went     entered          went to C)
    to C)    at MSB)
```

**Worked Example:**
```
Before: C = 0,  R = 1 0 1 1 0 1 0 1

Step 1: LSB (1) → goes into C
Step 2: All bits shift right
Step 3: Old C (0) → enters at MSB

After:  C = 1,  R = 0 1 0 1 1 0 1 0
```

---

## 7. All Shift Types — Master Summary Table

| Shift Type | RTL | Direction | What enters vacant position | What is lost |
|------------|-----|-----------|----------------------------|--------------|
| Logical Left | `shl R` | ← | **0** at LSB | MSB (permanently lost) |
| Logical Right | `shr R` | → | **0** at MSB | LSB (permanently lost) |
| Arithmetic Left | `shl R` | ← | **0** at LSB | MSB (overflow possible) |
| Arithmetic Right | `shr R` | → | **Sign bit copy** at MSB | LSB (permanently lost) |
| Circular Left | `cil R` | ← | **MSB wraps** to LSB | Nothing lost |
| Circular Right | `cir R` | → | **LSB wraps** to MSB | Nothing lost |
| Rotate Left (Carry) | `rcl R` | ← | **Old C** at LSB | MSB → goes to C |
| Rotate Right (Carry) | `rcr R` | → | **Old C** at MSB | LSB → goes to C |

---

## 8. Arithmetic Significance of Shifts

| Operation | Mathematical Effect | Condition |
|-----------|--------------------|-----------| 
| Shift Left (any type) | × 2 (Multiply by 2) | No overflow |
| Shift Right (logical) | ÷ 2 (Divide by 2) | Unsigned numbers only |
| Shift Right (arithmetic) | ÷ 2 (Divide by 2) | Signed numbers — sign preserved |

**Examples:**
```
R = 0 0 0 0 1 0 0 0  = 8

After shl:  0 0 0 1 0 0 0 0  = 16  (8 × 2 = 16 ✓)
After shr:  0 0 0 0 0 1 0 0  = 4   (8 ÷ 2 = 4  ✓)
After shl twice: 0 0 1 0 0 0 0 0 = 32  (8 × 4 = 32 ✓)
```

---

## 9. Hardware — Shift Register

### What is a Shift Register?

A **shift register** is a hardware circuit made of **D Flip-Flops connected in series** that stores and shifts binary data.

### Circuit Diagram (4-bit Shift Register — Shift Right)

```
               Clock (CLK)
                  │  │  │  │
                  ↓  ↓  ↓  ↓
Serial In ──→ [FF3]─→[FF2]─→[FF1]─→[FF0] ──→ Serial Out
               │      │      │      │
              Q3     Q2     Q1     Q0
               ↓      ↓      ↓      ↓
                    Parallel Output
```

**How it works:**
- Each **D Flip-Flop (FF)** stores 1 bit
- On every clock pulse, data shifts from one FF to the next
- 4 FFs → 4-bit shift register

---

### 4 Types of Shift Registers

| Type | Short Form | Data Input | Data Output | Use Case |
|------|-----------|------------|-------------|---------|
| Serial In Serial Out | **SISO** | 1 bit at a time | 1 bit at a time | Delay lines |
| Serial In Parallel Out | **SIPO** | 1 bit at a time | All bits at once | Serial to parallel conversion |
| Parallel In Serial Out | **PISO** | All bits at once | 1 bit at a time | Parallel to serial conversion |
| Parallel In Parallel Out | **PIPO** | All bits at once | All bits at once | Buffer / storage |

**SIPO — Circuit Diagram:**
```
Serial In ──→ [FF3]─→[FF2]─→[FF1]─→[FF0]
               │      │      │      │
              Q3     Q2     Q1     Q0
               ↓      ↓      ↓      ↓
           ─────────────────────────────→  Parallel Output (all at once)
```

**Real-world uses:**
- **SIPO:** USB/Bluetooth data arrives serially → converted to parallel for CPU
- **PISO:** CPU sends parallel data → converted to serial for transmission
- **PIPO:** Temporary data buffer between two stages of a circuit

---
## 10. Expected Exam Questions

1. **What are shift micro-operations? Why are they important?**
2. **Explain Logical Shift Left and Right with diagrams and examples.**
3. **Explain Arithmetic Shift Left and Right. How does it differ from Logical Shift?**
4. **What is the significance of Arithmetic Right Shift for signed numbers?**
5. **Explain Circular Shift Left and Right with examples. Why are no bits lost?**
6. **What is Rotate Through Carry? Explain with diagram and example.**
7. **Compare Logical and Arithmetic Shift Right with an example of a negative number.**
8. **What is a shift register? Explain its types: SISO, SIPO, PISO, PIPO.**
9. **Draw the circuit diagram of a 4-bit serial-in parallel-out (SIPO) shift register.**
10. **Compare all three types of micro-operations: Arithmetic, Logic, and Shift.**
11. **What happens when Arithmetic Shift Left causes overflow? Give an example.**
12. **If R = 0 0 0 0 1 1 0 0, find the result after: (a) shl (b) shr (c) cil (d) cir**

---

*End of Shift Micro-Operations Notes ✅*
